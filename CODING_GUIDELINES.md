# Соглашение о типах

## Использование type:

Для объединения и пересечения типов: Если нужно создать новый тип, объединив или пересекая существующие.

```typescript
type Name = string
type Age = number
type Person = { name: Name; age: Age }
```

При работе с примитивными типами: Нужно использовать `type` для определения простых типов данных.

```typescript
type ID = string | number
```

Для определения сложных и условных типов: Когда нужно создать сложные или условные типы данных.

```typescript
type Result<T> = T extends Error ? { error: T } : { data: T }
```

Для union-типов

```typescript
type Status = 'В работе' | 'Выполнен' | 'Отменён'
```

## Использование interface:

Для объявления формы объекта: Когда нужно создать структуру объекта или интерфейса.

> Для нейминга нужно использовать префикс I

> Для React пропсов нужно всегда использовать interface

```typescript
interface IPerson {
  name: string
  age: number
}
```

Расширение интерфейсов: Когда нужно расширить существующий интерфейс.

```typescript
interface IEmployee extends IPerson {
  position: string
}
```

Для объявления контрактов API: При работе с внешними библиотеками или определениями API.

```typescript
interface IApiResponse {
  data: any
  statusCode: number
}
```

# Соглашение о файловой организации

### Изоляция компонентов и их зависимостей

Изоляция компонентов — это принцип, который рекомендует размещать каждый компонент в собственной директории и содержать в этой директории только те файлы, которые необходимы для работы этого компонента. Это позволяет упростить навигацию, поддержку и повторное использование компонентов.

### Преимущества изоляции компонентов:

`Чистота и читаемость:` Каждая директория компонента содержит только необходимый минимум файлов, что делает код более чистым и читаемым.

`Легкость поддержки:` При необходимости вносить изменения в компонент, разработчик видит только те файлы, которые относятся к этому компоненту, что упрощает поддержку и внесение изменений.

`Изоляция стилей и типов данных:` Стили, типы данных и другие ассоциированные файлы остаются внутри директории компонента, избегая конфликтов и путаницы.

### Зависимости между компонентами

Если компоненты строго зависят друг от друга, их директории должны располагаться внутри директории родительского компонента. Это особенно полезно в случае, когда компоненты являются частью одного более крупного модуля.

### Преимущества структуры зависимостей:

`Логическая организация:` Директории компонентов, связанных логически, находятся рядом, что облегчает понимание структуры проекта.

`Легкость навигации:` Разработчик легко может найти связанные компоненты, используя структуру директорий.

```
Table/
|-- Table.tsx          // Основной файл компонента Table
|-- Table.module.scss    // Общие стили для компонента Table
|-- Table.test.ts      // Тесты для компонента Table
|-- Table.types.ts     // Общие типы для компонента Table
|-- Table.hooks.ts     // Общие хуки для компонента Table
|
|-- EmployeesTable/    // Директория для EmployeesTable
|   |-- EmployeesTable.tsx       // Основной файл компонента EmployeesTable
|   |-- EmployeesTable.module.scss // Стили для компонента EmployeesTable
|   |-- EmployeesTable.test.ts   // Тесты для компонента EmployeesTable
|   |-- EmployeesTable.types.ts  // Типы для компонента EmployeesTable
|   |-- EmployeesTable.hooks.ts  // Хуки для компонента EmployeesTable
|
|-- PlansTable/        // Директория для PlansTable
|   |-- PlansTable.tsx       // Основной файл компонента PlansTable
|   |-- PlansTable.module.scss // Стили для компонента PlansTable
|   |-- PlansTable.test.ts   // Тесты для компонента PlansTable
|   |-- PlansTable.types.ts  // Типы для компонента PlansTable
|   |-- PlansTable.hooks.ts  // Хуки для компонента PlansTable
|
|-- index.ts // Файл для экспорта компонентов
```

В данной структуре компоненты `EmployeesTable` и `PlansTable` изолированы в своих директориях, а их директории вложены в директорию компонента `Table`, так как они используют общий код вынесеный в `Table` во избежании его дублирования.

**Примеры суффиксов:**

- `types` - **_.types.ts_**
  Файл содержит TypeScript-типы, такие как интерфейсы, типы данных и т.д.

- `styles` - **_.styles.ts_**
  Файл содержит стили, часто используемые с CSS-in-JS библиотеками или препроцессорами стилей.

- `module` - **_.module.ts_**
  Файл представляет собой модуль, который может содержать как логику, так и связанные стили.

- `hooks` - **_.hooks.ts_**
  Файл содержит пользовательские хуки React или другие типы хуков.

- `helpers` - **_.helpers.ts_**
  Файл содержит вспомогательные функции, которые могут быть использованы в разных частях проекта.

- `constants` - **_.constants.ts_**
  Файл содержит константы, такие как значения, которые используются в различных частях приложения.

- `test` `(spec)` - **_.test.ts_** (или **_.spec.ts_**)
  Файл содержит тесты (unit tests, integration tests) для соответствующего кода.

**В случае когда какой-то код (типы, хуки, хэлперы и т.д) используются в компонентах которые не имеют прямой родительской директории**

Например:

```
src
|-- components/
|   |-- Dropdown.tsx // Использует типы которые используются в containers/TableDropdown.tsx
|
|-- containers/
|   |-- TableDropdown.tsx // Использует типы которые используются в components/Dropdown.tsx, НО НЕ ДЛЯ ТИПИЗАЦИИ КОМПОНЕНТА Dropdown
|
|-- types/
|   |-- index.ts // Общие типы
|
|-- helpers/
|   |-- index.ts // Общие хэлперы
|
|-- hooks/
|   |-- index.ts // Общие хуки
```

**Тогда такой код следует выносить в корневую директорию `src` в соответствующие поддиректории в файл `index.ts`**

# Семантические импорты

Для улучшения читаемости и единообразия следует придерживаться правил порядка импорта

1. В самом начале файла должны быть импорты React
2. Далее следует импортировать внешние библиотеки
3. Далее должны идти импорты внутренних компонентов
4. И в завершении испорты стилей

Пример:

```jsx
import React, { useState, useEffect } from 'react'
import cn from 'classnames'
import { nanoid } from 'nanoid'
import Dropdown from '../Dropdown'
import { ITableProps } from './Table.types'
import styles from './Table.module.scss'
```

# Умные (smart) и глупые (dumb) компоненты

> Эти соглашения позволят нам лучше организовывать код, повысить его читаемость и облегчить поддержку в процессе разработки.

Умные компоненты (Smart Components): Компоненты, ответственные за бизнес-логику, обработку данных и взаимодействие с внешними источниками данных. Они являются контейнерами для глупых компонентов и имеют доступ к состоянию и методам жизненного цикла React.

Глупые компоненты (Dumb Components): Компоненты, отвечающие за отображение интерфейса и не содержащие состояния или логику. Они получают данные и обработчики с умных компонентов через свойства (props) и являются максимально переиспользуемыми.

## Умные компоненты (Smart Components):

Умные компоненты должны находиться в директории `containers`.
Они должны быть ответственными за взаимодействие с хранилищем данных, обработку событий и передачу данных в глупые компоненты.

### Структура умных компонентов

Умные компоненты должны содержать минимальное количество логики отображения.
Старайтесь избегать стилей и ограничивайтесь минимальным количеством презентационных элементов.

```tsx
// Пример структуры умного компонента
// containers/MyContainer/MyContainer.tsx

import React, { useEffect } from 'react'
import { useDispatch, useSelector } from 'react-redux'
import { fetchUserData } from '../../actions/userActions'
import UserDataDisplay from '../../components/UserDataDisplay/UserDataDisplay'

const MyContainer: React.FC = () => {
  const dispatch = useDispatch()
  const userData = useSelector((state) => state.user.data)

  useEffect(() => {
    dispatch(fetchUserData())
  }, [dispatch])

  return <UserDataDisplay userData={userData} />
}

export default MyContainer
```

## Глупые компоненты (Dumb Components):

Глупые компоненты должны находиться в директории `components`.
Они должны быть ответственными за отображение интерфейса и максимально переиспользуемыми.

### Структура глупых компонентов

Глупые компоненты не должны содержать бизнес-логику и должны принимать данные через свойства (props).
Старайтесь избегать локального состояния в глупых компонентах, если это возможно.

```tsx
// Пример структуры глупого компонента
// components/UserDataDisplay/UserDataDisplay.tsx

import React from 'react'

interface UserDataDisplayProps {
  userData: {
    name: string
    age: number
    // другие свойства
  }
}

const UserDataDisplay: React.FC<UserDataDisplayProps> = ({ userData }) => {
  return (
    <div>
      <h2>User Data Display</h2>
      <p>Name: {userData.name}</p>
      <p>Age: {userData.age}</p>
      {/* другие элементы интерфейса */}
    </div>
  )
}

export default UserDataDisplay
```

# Нейминг веток

### Feature Branches (Ветки для новых функций):

`feature/{short-description}`

Пример: `feature/user-authentication`.

### Bugfix Branches (Ветки для исправления ошибок):

`bugfix/{short-description}`

Пример: `bugfix/fix-login-crash`.

### Refactoring Branches (Ветки для рефакторинга):

`refactor/{short-description}`

Пример: `refactor/update-logging`.

Старайтесь использовать понятные и краткие описания веток.
Используйте дефисы (-) или слэши (/) для разделения частей названия веток.

# Краткое соглашение по написанию коммитов:
Префиксы тегов:

- `feat`: Новая функциональность (feature).
- `fix`: Исправление ошибок (bug fix).
- `chore`: Рутинные задачи, изменения в инструментах, сборках и т.д.
- `style`: Изменения в стилях кода (не влияющие на его выполнение).
- `refactor`: Переработка кода без изменения его поведения.
- `test`: Добавление или изменение тестов.

Описание коммита:

- Используйте повелительное наклонение (Imperative Mood) в описании коммита.
- Начинайте описание со строчной буквы.
- Избегайте точек в конце описания.

Примеры коммитов:

- `feat: add authentication support`
- `fix: fix form validation error`
- `chore: update dependencies`
- `style: fix indentation in the file`
- `refactor: optimize search function`
- `test: add tests for the component`